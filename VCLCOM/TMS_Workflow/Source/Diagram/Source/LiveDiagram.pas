{***************************************************************************}
{ Diagram Studio                                                            }
{ for Delphi & C++Builder                                                   }
{                                                                           }
{ written by TMS Software                                                   }
{            copyright © 2003-2011                                          }
{            Email : info@tmssoftware.com                                   }
{            Web : http://www.tmssoftware.com                               }
{                                                                           }
{ LiveChart component - thanks to Davide Nardella for his contribution      }
{                                                                           }
{ The source code is given as is. The author is not responsible             }
{ for any possible damage done due to the use of this code.                 }
{ The components can be freely used in any application. The complete        }
{ source code remains property of the author and may not be distributed,    }
{ published, given or sold in any form as such. No parts of the source      }
{ code can be included in any other component or application without        }
{ written authorization of the author.                                      }
{***************************************************************************}

unit LiveDiagram;

{$I DIAGRAM.INC}

interface

Uses
  SysUtils, Windows, Classes, Messages, Controls, Graphics, atDiagram,
  DiagramUtils, Dialogs, MMSystem, DgrClasses;

Const
  {Codes for terminating execution

   Sys_End_Program: Interruption of execution. Any block can use it, the EndBlock uses it by default.
   Sys_Err_Exception: When an exception is raised while executing a block. Generates a xCode_Exception exit code
   Sys_Broken_Link: Is raised when the error handler block is executed and then there is no next block to be executed
   Sys_Unhandled_Error: Happens after another error is raised and there is no error block in diagram
   Sys_End_Path: End of an execution path. It happens when the execution path reaches a join block.
   Sys_Invalid_Join: The execution paths created by the same fork block end in different join blocks
  }
  Sys_End_Program       = -1;
  Sys_Err_Exception     = -2;
  Sys_Broken_Link       = -3;
  Sys_Unhandled_Error   = -4;
  Sys_End_Path          = -5;
  Sys_Invalid_Join      = -6;

  xNormal_termination    = 0; //Terminated by reaching an end-block
  xUser_termination      = 1; //Terminated by calling a method to stop execution (end-user termination)
  xProgram_termination   = 2; //Terminated by a block which is not an end-block
  xUnhandled_error       = 3; //Generated by an exception and no error handling was done
  xCode_Exception        = 4; //Generated by a Sys_Err_Exception
  xBroken_link           = 5; //Generated by a Sys_Broken_Link event, or after an error is handled and no next block is assigned
  xUnknow_SysError       = 6; //Terminated by an error that is not a known Sys_* error
  xWaitState_Termination = 7; //Terminated because the execution needs to be persistest
  xPath_termination      = 8; //Path terminated by reaching a join block
  xInvalid_Join          = 9; //Paths lead to different join block

type
  TLinkDirection = (ldInput,ldOutput);
  TExecutionPath = class;

  TLiveDiagram = class;
  TCustomLiveBlock = class;
  TLiveWire = class;
  TLiveSideWire = class;
  TLiveArc = class;
  TLiveBezier = class;

  TStateList = class(TList)
  private
    Transitions : TList;
    function GetBlock(index: integer): TCustomLiveBlock;
    function GetLink(index: integer): TCustomDiagramLine;
  public
    constructor Create;
    function Add(Transition : TCustomDiagramLine; aNext : TCustomLiveBlock) : integer;
    procedure Clear; override;
    destructor Destroy; override;
    property Transition[index : integer] : TCustomDiagramLine read GetLink;
    property Block[index : integer] : TCustomLiveBlock read GetBlock;
  end;

  TBlockColors = class(TPersistent)
  private
    Owner : TCustomLiveBlock;
    FRunONColor: TColor;
    FRunOFFColor: TColor;
    FRunERRColor: TColor;
    procedure SetFRunONColor(const Value: TColor);
    procedure SetFRunOFFColor(const Value: TColor);
    procedure SetFRunERRColor(const Value: TColor);
  public
    constructor create(AOwner : TCustomLiveBlock);
    procedure Assign(Source : TPersistent); override;
  published
    property RunONColor : TColor read FRunONColor write SetFRunONColor;
    property RunOFFColor : TColor read FRunOFFColor write SetFRunOFFColor;
    property RunERRColor : TColor read FRunERRColor write SetFRunERRColor;
  end;

  {wsUndefined: means that the wait state is still not defined yet. If continues undefined, then
                the behaviour in the end will be the same as wsNoWait
   wsNoWait: simply continue executing the workflow thread normally
   wsWaitAndSave: save the workflow state and terminate the execution thread. The execution should be
                  restarted again later
  }
  TWaitState = (wsUndefined, wsNoWait, wsWaitAndSave);

  TExecuteNodeInfo = record
    Decision: integer;
    Error: integer;
    ErrorMsg: string;
    RealErrorNode: TCustomLiveBlock;
    NextNode: TCustomLiveBlock;
    WaitState: TWaitState;
    Path: TExecutionPath;
    NextRunTime: TDateTime;
  end;

  TExecuteEvent = procedure(Sender : TCustomLiveBlock; Var Error, Decision : integer) of object;
  TExecuteExEvent = procedure(Sender: TCustomLiveBlock; var ExecInfo: TExecuteNodeInfo) of object;

  TControlState = (csEdit, csRunON, csRunOFF, csRunERR);

  TCustomLiveBlock = class(TCustomDiagramBlock)
  private
    FPassThrough: boolean;
    FControlState: TControlState;
    FStoreColor : TColor;
    FStoreGradient : boolean;
    FRunColors : TBlockColors;
    FIsErrorHandler: boolean;
    FIsEndBlock: boolean;
    FIsStartBlock: boolean;
    FOnExecuteEx: TExecuteExEvent;
    FNextStates: TStateList;
    FPreviousStates: TStateList;
    procedure SetFControlState(const Value: TControlState);
    procedure SetFRunColors(const Value: TBlockColors);
    function GetLiveDiagram: TLiveDiagram;
  protected
    FNext : TCustomLiveBlock;
    FOnExecute: TExecuteEvent;
    function Anchoreds: integer; overload;
    function Anchoreds(adirection: TLinkDirection): integer; overload;
    function GetNextAt(ALinkNum : integer) : TCustomLiveBlock;
    procedure UpdateLinkPoints; virtual;
    function SurroundRgn: TDotArray; override;
    procedure GetBlockPath(APath: TDgrGraphicsPath; ADrawer: TDgrBlockDrawer); override;
    function BlockPolygon: TDotArray; virtual;
    procedure DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo); override;
    function GetNext: TCustomLiveBlock; virtual;
    function AcceptLink(ALink: TCustomDiagramLine; LinkIndex : integer; Direction : TLinkDirection) : boolean; virtual;
    procedure DoExecute(var Error, Decision: integer); virtual;
    procedure DoExecuteEx(var ExecInfo: TExecuteNodeInfo); virtual;
    procedure ShowState; virtual;
    procedure DrawCrossHairs(ACanvas: TCanvas; ABlockRect: TSquare);
    property NextStates: TStateList read FNextStates;
    property PreviousStates: TStateList read FPreviousStates;
    property LiveDiagram: TLiveDiagram read GetLiveDiagram;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DoBeforeRun; virtual;
    function Execute(var Error, Decision: integer) : TCustomLiveBlock; virtual;
    procedure ExecuteEx(var ExecInfo: TExecuteNodeInfo); virtual;
    function ValidateWire(aLine: TCustomDiagramLine;
      var aBlock: TCustomLiveBlock; Direction: TLinkDirection): boolean;
    procedure BuildStateList;
    function Link : boolean ; virtual;
    property IsErrorHandler : boolean read FIsErrorHandler write FIsErrorHandler;
    property IsStartBlock : boolean read FIsStartBlock write FIsStartBlock;
    property IsEndBlock : boolean read FIsEndBlock write FIsEndBlock;
    property PassThrough : boolean read FPassThrough write FPassThrough;
    property ControlState : TControlState read FControlState write SetFControlState;
    property Next : TCustomLiveBlock read GetNext;
    property OnExecute : TExecuteEvent read FOnExecute write FOnExecute;
    property OnExecuteEx: TExecuteExEvent read FOnExecuteEx write FOnExecuteEx;
  published
    property RunColors : TBlockColors read FRunColors write SetFRunColors;
    property LinkPointStyle;
    property Color;
    property SelColor;
    property Angle;
    property Brush;
    property SelBrush;
    property Pen;
    property Strings;
    property Alignment;
    property VertAlign;
    property ClipText;
    property WordWrap;
    property TextCells;
    property Restrictions;
    property Font;
    property DiagramFont;
    property MinWidth;
    property MinHeight;
    property Shadow;
    property ShowHint;
    property Hint;
    property ParentShowHint;
    property Gradient;
    property Bitmap;
    property BitmapMode;
    property BitmapTransparent;
    property Cursor;
    property StringData;
    property Visible;
    property Layer;
    property LayerName;
    property Transparency;
  end;

  TLiveLineJoin = class(TCustomLiveBlock)
  private
    Finding : boolean;
  protected
    function GetNext: TCustomLiveBlock; override;
    function BlockPolygon: TDotArray; override;
    procedure DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo); override;
  public
    constructor Create(AOwner : TComponent); override;
  end;

  TCustomLiveConnector = class(TCustomLiveBlock)
  protected
    function BlockPolygon: TDotArray; override;
    procedure GetTranslatedBlockPath(APath: TDgrGraphicsPath; ADrawer: TDgrBlockDrawer); override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TLiveConnectorSource = class(TCustomLiveConnector)
  private
    Finding : boolean;
  protected
    function AcceptLink(ALink: TCustomDiagramLine; LinkIndex : integer;
      Direction : TLinkDirection) : boolean; override;
    function GetNext : TCustomLiveBlock; override;
  public
    function Link : boolean; override;
  end;

  TLiveConnectorTarget = class(TCustomLiveConnector)
  private
    Finding : boolean;
  protected
    function GetNext: TCustomLiveBlock; override;
    procedure DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo); override;
    procedure UpdateLinkPoints; override;
    function AcceptLink(ALink: TCustomDiagramLine; LinkIndex : integer;
      Direction : TLinkDirection) : boolean; override;
  end;

  TForkThread = class;
  TExecutionPaths = class;
  TLiveForkBlock = class;

  TExecutionPath = class(TCollectionItem)
  private
    FExitCode: integer;
    FRunErrorMsg: string;
    FRunError: integer;
    FWaitState: TWaitState;
    FErrorNode: TCustomLiveBlock;
    FExecuteThread: TForkThread;
    FLastNode: TCustomLiveBlock;
    FNextNode: TCustomLiveBlock;
    FStartNode: TCustomLiveBlock;
    FFinished: boolean;
    FLastNodeStr: string;
    FNextNodeStr: string;
    FStartNodeStr: string;
    FDeleteFlag: boolean;
    FDataObj: TObject;
    FDataStr: string;
    FParentPath: TExecutionPath;
    function Paths: TExecutionPaths;
    function Diagram: TLiveDiagram;
    procedure DoOnShift(OldBlock, NewBlock : TCustomLiveBlock);
    procedure OnTerminateForkThread(Sender: TObject);
    procedure ExecuteNode;
    function GetLastNodeStr: string;
    function GetNextNodeStr: string;
    function GetStartNodeStr: string;
  public
    property ParentPath: TExecutionPath read FParentPath;
    property DataStr: string read FDataStr write FDataStr;
    property DataObj: TObject read FDataObj write FDataObj;
  published
    property ExitCode: integer read FExitCode write FExitCode;
    property RunError: integer read FRunError write FRunError;
    property WaitState: TWaitState read FWaitState write FWaitState;
    property Finished: boolean read FFinished write FFinished;
    property NextNodeStr: string read GetNextNodeStr write FNextNodeStr;
    property LastNodeStr: string read GetLastNodeStr write FLastNodeStr;
    property StartNodeStr: string read GetStartNodeStr write FStartNodeStr;
  end;

  TExecutionPaths = class(TOwnedCollection)
  private
    function GetItem(Index: integer): TExecutionPath;
  protected
    function Block: TLiveForkBlock;
  public
    function Add: TExecutionPath;
    function FindStart(aBlock: TCustomLiveBlock): TExecutionPath;
    property Items[Index: integer]: TExecutionPath read GetItem; default;
  end;

  TForkThread = class(TThread)
  private
    FPath: TExecutionPath;
  public
    constructor Create(aPath: TExecutionPath);
    procedure DoFinish(aExitCode : integer);
    procedure Execute;override;
    destructor Destroy;override;
  end;

  TLiveForkBlock = class(TCustomLiveBlock)
  private
    FPaths: TExecutionPaths;
    FThreadsCreated: boolean;
    FErrorPath: TExecutionPath;
    FSubThreads: TList;
    function AllPathsTerminatedOk: boolean;
    procedure TerminateSubThreads;
    function ForkLinkIsOk: boolean;
    procedure LoadPathsProp(Reader: TReader);
    procedure StorePathsProp(Writer: TWriter);
  protected
    procedure DoPathStart(APath: TExecutionPath); virtual;
    procedure DoPathTerminate(APath: TExecutionPath); virtual;
    procedure UpdateLinkPoints; override;
    procedure DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo); override;
    procedure Loaded; override;
    procedure DefineProperties(Filer: TFiler); override;
    function AcceptLink(ALink: TCustomDiagramLine; LinkIndex : integer;
      Direction : TLinkDirection) : boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DoBeforeRun; override;
    procedure ExecuteEx(var ExecInfo: TExecuteNodeInfo); override;
    function Link: boolean; override;
  end;

  TLiveJoinBlock = class(TCustomLiveBlock)
  protected
    procedure DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo); override;
    function AcceptLink(ALink: TCustomDiagramLine; LinkIndex : integer;
      Direction : TLinkDirection) : boolean; override;
    procedure UpdateLinkPoints; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure ExecuteEx(var ExecInfo: TExecuteNodeInfo); override;
    function Link: boolean; override;
  published
  end;

  TTransitionEvent = function(Sender : TCustomDiagramLine; FromBlock : TCustomLiveBlock) : boolean of object;

  TLiveWire = class(TDiagramLine)
  private
    FOnTransition: TTransitionEvent;
  protected
    procedure PaintControl(AInfo: TDiagramDrawInfo); override;
    procedure RecalcTextCells; override;
    function  DoTransition(Sender : TCustomLiveBlock) : boolean; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    function Transition(Sender : TCustomLiveBlock) : boolean; virtual;
  published
    property OnTransition : TTransitionEvent read FOnTransition write FOnTransition;
  end;

  TLiveSideWire = class(TDiagramSideLine)
  private
    FOnTransition: TTransitionEvent;
  protected
    procedure PaintControl(AInfo: TDiagramDrawInfo); override;
    procedure RecalcTextCells; override;
    function  DoTransition(Sender : TCustomLiveBlock) : boolean; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    function Transition(Sender : TCustomLiveBlock) : boolean; virtual;
  published
    property OnTransition : TTranSitionEvent read FOnTransition write FOnTransition;
  end;

  TLiveArc = class(TDiagramArc)
  private
    FOnTransition: TTransitionEvent;
  protected
    procedure PaintControl(AInfo: TDiagramDrawInfo); override;
    procedure RecalcTextCells; override;
    function  DoTransition(Sender : TCustomLiveBlock) : boolean; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    function Transition(Sender : TCustomLiveBlock) : boolean; virtual;
  published
    property OnTransition : TTranSitionEvent read FOnTransition write FOnTransition;
  end;

  TLiveBezier = class(TDiagramBezier)
  private
    FOnTransition: TTransitionEvent;
  protected
    procedure PaintControl(AInfo: TDiagramDrawInfo); override;
    procedure RecalcTextCells; override;
    function  DoTransition(Sender : TCustomLiveBlock) : boolean; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    function Transition(Sender : TCustomLiveBlock) : boolean; virtual;
  published
    property OnTransition : TTranSitionEvent read FOnTransition write FOnTransition;
  end;

  TDiagramThread = class(TThread)
  private
    FDiagram : TLiveDiagram;
  public
    constructor Create(aDiagram : TLiveDiagram);
  end;

  TExecuteThread = class(TDiagramThread)
  public
    procedure DoFinish(aExitCode : integer);
    procedure Execute; override;
    destructor Destroy; override;
  end;

  TVisualThread = class(TDiagramThread)
  public
    procedure Execute;override;
    destructor Destroy;override;
  end;

  TRunErrorEvent = procedure(Sender : TLiveDiagram; Block : TCustomLiveBlock;
    var Error : integer; var ResumeNext : boolean) of object;

  TStartMode = (smCold, smWarm, smContinue);

  TStartEvent  = procedure(Sender : TLiveDiagram; StartMode : TStartMode) of object;

  TShiftEvent = procedure(Sender : TLiveDiagram; OldBlock, NewBlock : TCustomLiveBlock) of object;

  TTerminateEvent = procedure(Sender : TLiveDiagram; ExitCode : integer) of object;


  TDiagramState = (dsEdit, dsRunning, dsPaused, dsView);
  TDiagramAction= (daRun, daRunPaused, daPause, daStop, daForceStop, daReset, daStep, daContinue, daContinuePaused);

  TChangeStateEvent = procedure(Sender : TLiveDiagram; NewState : TDiagramState) of object;

  TViewStateMode = (vmStart, vmRun, vmEnd);

  TLiveDiagram = class(TatDiagram)
  private
    FRunError : integer;
    FRunErrorMsg: string;
    Linked : boolean;
    FState: TDiagramState;
    ExecuteThread : TExecuteThread;
    VisualThread : TVisualThread;
    FLiveds : TList;
    FOnRunError : TRunErrorEvent;
    FExitCode: integer;
    FStoreShowLinkPts : boolean;
    FStoreSnapGrid : boolean;
    FStoreColor : TColor;
    FRunColor : TColor;
    FSleepVisual: dword;
    FIdlePercent: dword;
    FOnTerminate: TTerminateEvent;
    FOnStart: TStartEvent;
    FOnChangeState: TChangeStateEvent;
    FOnShift: TShiftEvent;
    FOnMouseLeave: TNotifyEvent;
    FOnMouseEnter: TNotifyEvent;
    FWaitState: TWaitState;
    FOnSaveState: TNotifyEvent;
    FOnLoadState: TNotifyEvent;
    FSavingState: boolean;
    FNextNodeStr: string;
    FLastNodeStr: string;
    FErrorNodeStr: string;
    FSubThreads: TList;
    FCanResumeNext: boolean;
    FViewStateMode: TViewStateMode;
    FStart : TCustomLiveBlock;
    FEnd : TCustomLiveBlock;
    FMaximumIdle: dword;
    procedure SetFState(const Value: TDiagramState);
    procedure SetFSleepVisual(const Value: dword);
    function GetLived(index: integer): TCustomLiveBlock;
    procedure SetFRunColor(const Value: TColor);
    procedure UnhandledRunError;
    procedure SetFIdlePercent(const Value: dword);
    procedure LoadLastNodeProp(Reader: TReader);
    procedure StoreLastNodeProp(Writer: TWriter);
    procedure ForceTerminateSubThreads;
    procedure LoadErrorNodeProp(Reader: TReader);
    procedure LoadRunErrorMsgProp(Reader: TReader);
    procedure StoreErrorNodeProp(Writer: TWriter);
    procedure StoreRunErrorMsgProp(Writer: TWriter);
  protected
    FErrorHandler : TCustomLiveBlock;
    StepEvent : THandle;
    StepMode  : boolean;
    function AcceptLink(ALink: TCustomDiagramLine; Anchor1, Anchor2: TLinkPoint): boolean; override;
    procedure CMMouseEnter(var Message: TMessage);message CM_MOUSEENTER;
    procedure CMMouseLeave(var Message: TMessage);message CM_MOUSELEAVE;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure Loaded; override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure LoadNextNodeProp(Reader: TReader);
    procedure StoreNextNodeProp(Writer: TWriter);
    procedure DoOnChangeState; virtual;
    procedure DoOnStart(StartMode : TStartMode); virtual;
    procedure DoOnShift(OldBlock, NewBlock : TCustomLiveBlock); virtual;
    procedure DoOnTerminate(Sender : TObject); virtual;
    procedure DoOnRunError(Block : TCustomLiveBlock; var Error : integer; var ResumeNext : boolean); virtual;
    procedure DoStop(TheExitCode : integer); virtual;
    procedure DoForceStop; virtual;
    procedure DoStep; virtual;
    procedure DoPause; virtual;
    procedure DoRun; virtual;
    procedure DoReset(Continue: boolean = false); virtual;
    procedure ExecuteNode; virtual;
    procedure PaintExecute;
    procedure DoLoadState; virtual;
    procedure DoSaveState; virtual;
    procedure TerminateSubThreads;
    procedure DoBeforeExecuteNode(ANode: TCustomLiveBlock); virtual;
    procedure DoAfterExecuteNode(ANode: TCustomLiveBlock); virtual;
    function DiagramStreamClass: TatDiagramClass; override;
    property StartBlock: TCustomLiveBlock read FStart;
    property EndBlock: TCustomLiveBlock read FEnd;
  public
    LastNode  : TCustomLiveBlock;
    NextNode  : TCustomLiveBlock;
    ErrorNode : TCustomLiveBlock;
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;
    procedure Modified; override;
    function Link : boolean; virtual;
    function PrepareRun : boolean; virtual;
    procedure DoAction(Action : TDiagramAction);
    procedure SaveStateToStream(AStream: TStream; TextFormat: boolean = false);
    procedure LoadStateFromStream(AStream: TStream; TextFormat: boolean = false);
    procedure SaveState;
    procedure LoadState;
    procedure MakeActiveNodeVisible;
    property SavingState: boolean read FSavingState;
    property State : TDiagramState read FState write SetFState;
    property RunError : integer read FRunError;
    property RunErrorMsg: string read FRunErrorMsg;
    property ExitCode : integer read FExitCode;
    property Liveds[index : integer] : TCustomLiveBlock read GetLived;
    property ViewStateMode: TViewStateMode read FViewStateMode write FViewStateMode;
    property MaximumIdle: dword read FMaximumIdle write FMaximumIdle;
  published
    property IdlePercent : dword read FIdlePercent write SetFIdlePercent default 0;
    property SleepVisual : dword read FSleepVisual write SetFSleepVisual default 0;
    property RunColor : TColor read FRunColor write SetFRunColor default 0;
    property OnSaveState: TNotifyEvent read FOnSaveState write FOnSaveState;
    property OnLoadState: TNotifyEvent read FOnLoadState write FOnLoadState;
    property OnMouseEnter : TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave : TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
    property OnUnhandledRunError : TRunErrorEvent read FOnRunError write FOnRunError;
    property OnStart : TStartEvent read FOnStart write FOnStart;
    property OnShift : TShiftEvent read FOnShift write FOnShift;
    property OnTerminate : TTerminateEvent read FOnTerminate write FOnTerminate;
    property OnChangeState : TChangeStateEvent read FOnChangeState write FOnChangeState;
  end;
                                                            
  TLiveStreamDiagram = class(TLiveDiagram)
  private
    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
  protected
  public
    procedure PaintWindow(DC: HDC); override;
    constructor Create(Owner: TComponent); override;
  end;

{$R LiveDiagram.res}

implementation

procedure KillThread(aThread: TThread);
begin
  if Assigned(aThread) then
  with aThread do
  begin
    {$WARNINGS OFF}
    Suspend;
    {$WARNINGS ON}
    Terminate;
    {$WARNINGS OFF}
    Resume;
    {$WARNINGS ON}
  end;
end;

{ TStateList }

function TStateList.Add(Transition: TCustomDiagramLine;
  aNext: TCustomLiveBlock): integer;
begin
  Transitions.Add(Transition);
  Result := inherited Add(aNext);
end;

procedure TStateList.Clear;
begin
  inherited;
  if Assigned(Transitions) then
    Transitions.Clear;
end;

constructor TStateList.Create;
begin
  Transitions := TList.Create;
end;

destructor TStateList.Destroy;
begin
  Transitions.Free;
  Transitions := nil;
  inherited;
end;

function TStateList.GetBlock(index: integer): TCustomLiveBlock;
begin
{$WARNINGS OFF}
  Result:=TCustomLiveBlock(Items[index]);
{$WARNINGS ON}
end;

function TStateList.GetLink(index: integer): TCustomDiagramLine;
begin
{$WARNINGS OFF}
  Result:=TCustomDiagramLine(Transitions[index]);
{$WARNINGS ON}
end;

{ TBlockColors }

procedure TBlockColors.Assign(Source: TPersistent);
begin
  if Source is TBlockColors then
  begin
    FRunONColor := TBlockColors(Source).RunONColor;
    FRunOFFColor:= TBlockColors(Source).RunOFFColor;
    FRunERRColor:= TBlockColors(Source).RunERRColor;
  end
  else
    inherited Assign(Source);
end;

constructor TBlockColors.create(AOwner: TCustomLiveBlock);
begin
  OWner := AOWner;
  FRunONColor:=clLime;
  FRunOFFColor:=clBtnFace;
  FRunERRColor:=clRed;
end;

procedure TBlockColors.SetFRunERRColor(const Value: TColor);
begin
  if FRunERRColor <> Value then
  begin
    FRunERRColor := Value;
    Owner.Redraw;
  end;
end;

procedure TBlockColors.SetFRunOFFColor(const Value: TColor);
begin
  if FRunOFFColor <> Value then
  begin
    FRunOFFColor := Value;
    Owner.Redraw;
  end;
end;

procedure TBlockColors.SetFRunONColor(const Value: TColor);
begin
  if FRunONColor <> Value then
  begin
    FRunONColor := Value;
    Owner.Redraw;
  end;
end;

{ TCustomLiveBlock }

function TCustomLiveBlock.AcceptLink(ALink: TCustomDiagramLine;
  LinkIndex: integer; Direction: TLinkDirection): boolean;
begin
//            0
//      +-----+-----+
//      |           !
//    3 +           + 1
//      |           |
//      +-----+-----+
//            2
// Default behaviour for boxes
//
// 0,1,3 : input, multiple links allowed of ldInput type
// 2     : output, one link allowed of ldOutput type
//
//
  Result:=((LinkIndex in [0,1,3]) and (Direction=ldInput)) or
          ((LinkIndex = 2) and (Direction=ldOutput) and (LinkPoints[2].AnchoredCount=0));
end;

constructor TCustomLiveBlock.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FNextStates := TStateList.Create;
  FPreviousStates := TStateList.Create;
  FRunColors:=TBlockColors.create(self);
  OriginalRect := Square(0, 0, 100, 100);
  Width := 100;
  Height := 50;
  UpdateLinkPoints;
  Shape := bsNoShape;
  Alignment := taCenter;
  VertAlign := vaCenter;
  ShapeCursor := True;
  FIsStartBlock:=false;
  FIsEndBlock:=false;
  FIsErrorHandler:=false;
  FPassThrough:=false;
  FControlState := csEdit;
  Font.Name:='Arial';
end;

destructor TCustomLiveBlock.Destroy;
begin
  FNextStates.Free;
  FPreviousStates.Free;
  FRunColors.Free;
  inherited;
end;

procedure TCustomLiveBlock.DoExecute(var Error, Decision: integer);
begin
  if Assigned(FOnExecute) then
    FOnExecute(self, Error, Decision);
end;

procedure TCustomLiveBlock.DoExecuteEx(var ExecInfo: TExecuteNodeInfo);
begin
  if Assigned(FOnExecuteEx) then
    FOnExecuteEx(self, ExecInfo);
end;

procedure TCustomLiveBlock.DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo);
begin
  inherited;
  if PathDrawingMode then
    inherited            
  else
  begin
    AInfo.Canvas.Polygon(RoundDotArray(BlockPolygon));
    DrawCrossHairs(AInfo.Canvas, ABlockInfo.Rect);
  end;
end;

function TCustomLiveBlock.Execute(var Error, Decision: integer) : TCustomLiveBlock;
begin
  try
    DoExecute(Error, Decision);
  except
    Error := Sys_Err_Exception; // Runtime Error in DoExecute
    ControlState := csRunERR;
  end;
  Result := FNext;
end;

procedure TCustomLiveBlock.ExecuteEx(var ExecInfo: TExecuteNodeInfo);
begin
  ExecInfo.Error := 0;
  ExecInfo.ErrorMsg := '';
  ExecInfo.RealErrorNode := nil;
  ExecInfo.Decision := 0;
  ExecInfo.WaitState := wsUndefined;
  ExecInfo.NextNode := Execute(ExecInfo.Error, ExecInfo.Decision);
  ExecInfo.NextRunTime := 0;
  try
    DoExecuteEx(ExecInfo);
  except
    on e: Exception do
    begin
      ExecInfo.Error := Sys_Err_Exception;
      ExecInfo.ErrorMsg := e.Message;
      ControlState := csRunERR;
    end;
  end;
end;

function TCustomLiveBlock.GetNext: TCustomLiveBlock;
begin
  if not Assigned(FNext) then
    FNext:=GetNextAt(2);
  Result:=FNext;
end;

function TCustomLiveBlock.GetNextAt(ALinkNum: integer): TCustomLiveBlock;
Var
  aLink  : TCustomDiagramLine;
  aBlock : TCustomLiveBlock;
begin
  Result:=nil;;

  if LinkPoints[ALinkNum].AnchoredCount=0 then  // no connection
    exit;

  if Assigned(LinkPoints[ALinkNum].Anchoreds[0]) and
     (LinkPoints[ALinkNum].Anchoreds[0].DControl is TCustomDiagramLine) then
  begin
    aLink:=TCustomDiagramLine(LinkPoints[ALinkNum].Anchoreds[0].DControl);
    if ValidateWire(aLink, aBlock, ldOutput) then
    begin
      if aBlock.PassThrough then
        aBlock:=aBlock.Next;
      Result:=aBlock;
    end;
  end;
end;

procedure TCustomLiveBlock.DoBeforeRun;
begin
// Override this method to perform init stuff before run;
end;

function TCustomLiveBlock.Link: boolean;
begin
  FNext:=nil;
  FNext:=Next;
  Result:=FNext<>nil;
end;

procedure TCustomLiveBlock.SetFControlState(const Value: TControlState);

  procedure Store;
  begin
    FStoreColor:=Color;
    FStoreGradient:=Gradient.Visible;
    Gradient.Visible:=false;
  end;

  procedure Restore;
  begin
    Color:=FStoreColor;
    Gradient.Visible:=FStoreGradient;
  end;

begin
  if FControlState <> Value then
  begin
    if Value=csEdit then
      Restore
    else
      if FControlState=csEdit then
        Store;
    FControlState := Value;
  end;
end;

procedure TCustomLiveBlock.SetFRunColors(const Value: TBlockColors);
begin
  FRunColors.Assign(Value);
end;

procedure TCustomLiveBlock.ShowState;
begin
  case FControlState of
    csRunOFF : Color := FRunColors.FRunOFFColor;
    csRunON  : Color := FRunColors.FRunONColor;
    csRunERR : Color := FRunColors.FRunERRColor;
  end;
end;

function TCustomLiveBlock.SurroundRgn: TDotArray;
begin
  if not PathDrawingMode then
  begin
    Drawer.CurRect := BoundsRect;
    Drawer.Angle := Angle;
    result := BlockPolygon;
  end;
end;

procedure TCustomLiveBlock.UpdateLinkPoints;
begin
  LinkPoints.Clear;
  with Drawer.OriginalRect do
  begin
    LinkPoints.Add((Right - Left) / 2, Top, aoUp);        // 0
    LinkPoints.Add(Right, (Bottom - Top) / 2, aoRight);   // 1
    LinkPoints.Add((Right - Left) / 2, Bottom, aoDown);   // 2
    LinkPoints.Add(Left, (Bottom - Top) / 2, aoLeft);     // 3
  end;
end;

function TCustomLiveBlock.ValidateWire(aLine: TCustomDiagramLine;
  var aBlock: TCustomLiveBlock; Direction: TLinkDirection): boolean;
var
  Source: TCustomLiveBlock;
  Target: TCustomLiveBlock;
begin
  Source := nil;
  Target := nil;
  if aLine.InheritsFrom(TLiveWire) or
     aLine.InheritsFrom(TLiveSideWire) or
     aLine.InheritsFrom(TLiveArc) or
     aLine.InheritsFrom(TLiveBezier) then
  begin
    if Assigned(aLine.SourceLinkPoint) and
       Assigned(aLine.SourceLinkPoint.Anchor) and
       aLine.SourceLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) then
      Source:=TCustomLiveBlock(aLine.SourceLinkPoint.Anchor);
    if Assigned(aLine.TargetLinkPoint) and
       Assigned(aLine.TargetLinkPoint.Anchor) and
       aLine.TargetLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) then
      Target:=TCustomLiveBlock(aLine.TargetLinkPoint.Anchor);
  end;

  result := false;
  Case Direction of
    ldOutput:
      begin
        Result := (Source = self) and Assigned(Target);
        aBlock := Target;
      end;
    ldInput:
      begin
        Result := (Target = self) and Assigned(Source);
        aBlock := Source;
      end;
  end;
end;

function TCustomLiveBlock.Anchoreds: integer;
Var
  c : integer;
begin
  Result:=0;
  for c:=0 to Linkpoints.Count-1 do
    Result:=Result+Linkpoints[c].AnchoredCount;
end;

function TCustomLiveBlock.Anchoreds(adirection: TLinkDirection): integer;
Var
  c: integer;
  d: integer;
  aLink: TCustomDiagramLine;
begin
  Result := 0;
  for c := 0 to Linkpoints.Count - 1 do
    for d := 0 to LinkPoints[c].AnchoredCount - 1 do
      if Assigned(LinkPoints[c].Anchoreds[d]) and
         (LinkPoints[c].Anchoreds[d].DControl is TCustomDiagramLine) then
      begin
        aLink := TCustomDiagramLine(LinkPoints[c].Anchoreds[d].DControl);
        Case aDirection of
          ldInput:
            if aLink.TargetLinkPoint.Anchor = Self then
              inc(result);
          ldOutput:
            if aLink.SourceLinkPoint.Anchor = Self then
              inc(result);
        end;
      end;
end;

procedure TCustomLiveBlock.BuildStateList;
Var
  idl, ida : integer;
  aLink  : TCustomDiagramLine;
  aBlock : TCustomLiveBlock;
begin
  FNextStates.Clear;
  FPreviousStates.Clear;

  for idl := 0 to LinkPoints.Count - 1 do
  for ida := 0 to LinkPoints[idl].AnchoredCount - 1 do
  begin
    if Assigned(LinkPoints[idl].Anchoreds[ida]) and
      (LinkPoints[idl].Anchoreds[ida].DControl is TCustomDiagramLine) then
    begin
      aLink := TCustomDiagramLine(LinkPoints[idl].Anchoreds[ida].DControl);
      if aLink.SourceLinkPoint.Anchor = self then
      begin
        if ValidateWire(aLink, aBlock, ldOutput) then
        begin
          if aBlock.PassThrough then
            aBlock := aBlock.Next;
          FNextStates.Add(aLink, aBlock);
        end
        else
          Exit; // Bad Link
      end
      else
      if aLink.TargetLinkPoint.Anchor = self then
      begin
        if ValidateWire(aLink, aBlock, ldInput) then
          FPreviousStates.Add(aLink, aBlock)
        else
          Exit; // Bad Link
      end;
    end;
  end;
end;

function TCustomLiveBlock.BlockPolygon: TDotArray;
begin
  with Drawer, OriginalRect do
  begin
    result := RotPoly(DotArray([
      PP(Left, Top),
      PP(Right, Top),
      PP(Right, Bottom),
      PP(Left, Bottom),
      PP(Left, Top)
      ]));
  end;
end;

function TCustomLiveBlock.GetLiveDiagram: TLiveDiagram;
begin
  if Diagram is TLiveDiagram then
    result := TLiveDiagram(Diagram)
  else
    result := nil;
end;

procedure TCustomLiveBlock.GetBlockPath(APath: TDgrGraphicsPath; ADrawer: TDgrBlockDrawer);
begin
  APath.Reset;
  APath.AddRectangle(ADrawer.SourceRect);
end;

procedure TCustomLiveBlock.DrawCrossHairs(ACanvas: TCanvas; ABlockRect: TSquare);
begin
  if Assigned(Diagram) and (Diagram.MouseState=msMoving) and (ControlState=csEdit) and (Diagram.DragStyle = dsOutline) then
  begin
    ACanvas.MoveTo(Round((ABlockRect.Left + ABlockRect.Right) / 2), ACanvas.ClipRect.Top);
    ACanvas.LineTo(Round((ABlockRect.Left + ABlockRect.Right) / 2), ACanvas.ClipRect.Bottom);
    ACanvas.MoveTo(ACanvas.ClipRect.Left, Round((ABlockRect.Top + ABlockRect.Bottom) / 2));
    ACanvas.LineTo(ACanvas.ClipRect.Right, Round((ABlockRect.Top + ABlockRect.Bottom) / 2));
  end;
end;

{ TLiveLineJoin }

function TLiveLineJoin.BlockPolygon: TDotArray;
begin
  with Drawer do
  begin
    result := RotPoly(DotArray([
      PP(0, 0),
      PP(20,0),
      PP(20,20),
      PP(0,20),
      PP(0, 0)
      ]));
  end;
end;

constructor TLiveLineJoin.Create(AOwner: TComponent);
begin
  inherited;
  Color:=clBlack;
  SelColor:=clBlack;
  Width := 20;
  Height := 20;
  OriginalRect := Square(0, 0, 20, 20);
  UpdateBlockHandles;
  Restrictions:=Restrictions+[crNoResize];
  UpdateLinkPoints;
  FPassThrough:=true;
end;

procedure TLiveLineJoin.DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo);
var
  bc,pc : integer;
  path: TDgrGraphicsPath;
begin
  if PathDrawingMode then
  begin
    path := AInfo.DgrDrawer.CreatePath;
    try
      path.Reset;
      path.AddLine(10, 0, 10, 20);
      path.StartFigure;
      path.AddLine(0, 10, 20, 10);
      AInfo.DgrDrawer.TransformPath(path);
      AInfo.DgrDrawer.Canvas.DrawPath(path);
    finally
      path.Free;
    end;
  end
  else
  begin
    DrawCrossHairs(AInfo.Canvas, ABlockInfo.Rect);
    with AInfo.Canvas, AInfo.Drawer do
    begin
      bc:=Brush.color;
      pc:=Pen.Color;
      if Selected then
        Brush.Color:=Self.SelColor
      else
        Brush.Color:=Self.Color;
      Pen.Color:=Self.Pen.Color;
      AutoMoveTo(10,0);
      AutoLineTo(10,20);
      AutoMoveTo(0,10);
      AutoLineTo(20,10);
      Brush.Color:=bc;
      Pen.Color:=pc;
    end;
  end;
end;

function TLiveLineJoin.GetNext: TCustomLiveBlock;
begin
  Result:=nil;
  FNext :=nil;

  if Finding then  // Search link recursion
  begin
    Finding:=false;
    exit;
  end
  else
    Finding:=true;

  FNext:=GetNextAt(2);
  Result:=FNext;
  Finding:=false;
end;

{ TCustomLiveConnector }

function TCustomLiveConnector.BlockPolygon: TDotArray;
var
  P1, P2: TDot;
  D: number;
begin
  with Drawer.OriginalRect do
  begin
    P1 := Drawer.PP(Left, Top);
    P2 := Drawer.PP(Right, Bottom);
  end;
  D := P2.Y - P1.Y;
  result := Drawer.RotPoly(GetPolyRoundRect(P1.X, P1.Y, P2.X, P2.Y, D, D));
end;

constructor TCustomLiveConnector.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 40;
  Height := 40;
  TextCells[0].Text:='A';
  FPassThrough:=true;
end;

procedure TCustomLiveConnector.GetTranslatedBlockPath(APath: TDgrGraphicsPath; ADrawer: TDgrBlockDrawer);
begin
  APath.Reset;
  with ADrawer.DestRect do
    ADrawer.Canvas.AddRoundRectPath(APath, Left, Top, Right, Bottom, Bottom - Top, Bottom - Top);
  ADrawer.RotatePath(APath);
end;

{ TLiveConnectorTarget }

function TLiveConnectorTarget.AcceptLink(ALink: TCustomDiagramLine;
  LinkIndex: integer; Direction: TLinkDirection): boolean;
begin
  Result:=(LinkIndex = 0) and (Direction=ldOutput) and (LinkPoints[0].AnchoredCount=0);
end;

procedure TLiveConnectorTarget.DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo);
var
  path: TDgrGraphicsPath;
begin
  inherited;
  if PathDrawingMode then
  begin
    path := AInfo.DgrDrawer.CreatePath;
    try
      path.AddLine(40, 85, 60, 85);
      path.AddLine(50, 100, 40, 85);
      path.CloseFigure;
      AInfo.DgrDrawer.TransformPath(path);
      AInfo.DgrDrawer.Canvas.Brush.Color := clBlue;
      AInfo.DgrDrawer.Canvas.Path(path);
    finally
      path.Free;
    end;
  end
  else
  begin
    if Assigned(Diagram) and
      (
        (Diagram.DragStyle = dsShape)
        or
        ((Diagram.MouseState <> msMoving) and (Diagram.MouseState <> msResizing))
       ) then
    begin
      AInfo.Drawer.Canvas := AInfo.Canvas;
      AInfo.Drawer.Angle := Angle;
      with AInfo.Drawer, Canvas do
      begin
        Pen := Self.Pen;
        Brush.Style := bsSolid;
        Brush.Color := clblue;
        CanvasPolygon(RoundDotArray(RotPoly(DotArray([PP(40,85), PP(60,85), PP(50,100), PP(40,85)]))));
      end;
    end;
  end;
end;

function TLiveConnectorTarget.GetNext: TCustomLiveBlock;
begin
  Result:=nil;
  FNext :=nil;

  if Finding then  // Link recursion
  begin
    Finding:=false;
    exit;
  end
  else
    Finding:=true;

  FNext:=GetNextAt(0);
  Result:=FNext;
  Finding:=false;
end;

procedure TLiveConnectorTarget.UpdateLinkPoints;
begin
  LinkPoints.Clear;
  with Drawer.OriginalRect do
    LinkPoints.Add((Right - Left) / 2, Bottom, aoDown);   // 0 output
end;

{ TLiveConnectorSource }

function TLiveConnectorSource.AcceptLink(ALink: TCustomDiagramLine;
  LinkIndex: integer; Direction: TLinkDirection): boolean;
begin
  Result:=Direction=ldInput;
end;

function TLiveConnectorSource.GetNext: TCustomLiveBlock;
Var
 c: integer;
begin
  if Assigned(FNext) then
  begin
    Result:=FNext;
    Exit;
  end;

  Result:=nil;

  if Finding then
  begin
    Finding:=false;
    exit;
  end;

  Finding := true;
  With Diagram do
  begin
    for c:=0 to BlockCount-1 do
    begin
      if Blocks[c] is TLiveConnectorTarget then
      begin
        if AnsiCompareText(TLiveConnectorTarget(Blocks[c]).TextCells[0].Text,TextCells[0].Text)=0 then
        begin
          Result:=TLiveConnectorTarget(Blocks[c]).Next;
          Finding:=false;
          exit;
        end;
      end;
    end;
  end;

  Finding:=false;
end;

function TLiveConnectorSource.Link: boolean;
begin
  Result := true;
end;

{ TLiveWire }

constructor TLiveWire.Create(AOwner: TComponent);
begin
  inherited;
  TargetArrow.Shape:=asSolidArrow;
end;

function TLiveWire.DoTransition(Sender : TCustomLiveBlock): boolean;
begin
  if Assigned(FOnTransition) then
    Result:=FOnTransition(Self,Sender)
  else
    Result:=false;
end;


procedure TLiveWire.PaintControl(AInfo: TDiagramDrawInfo);
var
  aStyle, aSelStyle: TPenStyle;
begin
  if Assigned(SourceLinkPoint) and Assigned(SourceLinkPoint.Anchor) and
     SourceLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) and
     Assigned(TargetLinkPoint) and Assigned(TargetLinkPoint.Anchor) and
     TargetLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock)
  then
    inherited
  else
  begin
    // since CurPen function is not virtual, we need a little trick
    aStyle       := Pen.Style;
    aSelStyle    := SelPen.Style;
    Pen.Style    := psDot;
    SelPen.Style := psDot;
    inherited;
    Pen.Style    := aStyle;
    SelPen.Style := aSelStyle;
  end;
end;

procedure TLiveWire.RecalcTextCells;
begin
  inherited;
  if TextCells.Count>0 then
    TextCells[0].Left:=TextCells[0].Left-10;
end;

function TLiveWire.Transition(Sender : TCustomLiveBlock): boolean;
begin
  try
    Result:=DoTransition(Sender);
  except
    Result:=false; // Runtime Error in DoTransition
  end;
end;

{ TLiveSideWire }

constructor TLiveSideWire.Create(AOwner: TComponent);
begin
  inherited;
  TargetArrow.Shape:=asSolidArrow;
end;

function TLiveSideWire.DoTransition(Sender : TCustomLiveBlock): boolean;
begin
  if Assigned(FOnTransition) then
    Result:=FOnTransition(Self,Sender)
  else
    Result:=false;
end;

procedure TLiveSideWire.PaintControl(AInfo: TDiagramDrawInfo);
var
  aStyle, aSelStyle: TPenStyle;
begin
  if Assigned(SourceLinkPoint) and Assigned(SourceLinkPoint.Anchor) and
     SourceLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) and
     Assigned(TargetLinkPoint) and Assigned(TargetLinkPoint.Anchor) and
     TargetLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock)
  then
    inherited
  else
  begin
    // since CurPen function is not virtual, we need a little trick
    aStyle       := Pen.Style;
    aSelStyle    := SelPen.Style;
    Pen.Style    := psDot;
    SelPen.Style := psDot;
    inherited;
    Pen.Style    := aStyle;
    SelPen.Style := aSelStyle;
  end;
end;

procedure TLiveSideWire.RecalcTextCells;
begin
  inherited;
  if TextCells.Count>0 then
    TextCells[0].Left:=TextCells[0].Left-10;
end;

function TLiveSideWire.Transition(Sender : TCustomLiveBlock): boolean;
begin
  try
    Result:=DoTransition(Sender);
  except
    Result:=false; // Runtime Error in DoTransition
  end;
end;

{ TLiveArc }

constructor TLiveArc.Create(AOwner: TComponent);
begin
  inherited;
  TargetArrow.Shape:=asSolidArrow;
end;

function TLiveArc.DoTransition(Sender : TCustomLiveBlock): boolean;
begin
  if Assigned(FOnTransition) then
    Result:=FOnTransition(Self,Sender)
  else
    Result:=false;
end;

procedure TLiveArc.PaintControl(AInfo: TDiagramDrawInfo);
var
  aStyle, aSelStyle: TPenStyle;
begin
  if Assigned(SourceLinkPoint) and Assigned(SourceLinkPoint.Anchor) and
     SourceLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) and
     Assigned(TargetLinkPoint) and Assigned(TargetLinkPoint.Anchor) and
     TargetLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock)
  then
    inherited
  else
  begin
    // since CurPen function is not virtual, we need a little trick
    aStyle       := Pen.Style;
    aSelStyle    := SelPen.Style;
    Pen.Style    := psDot;
    SelPen.Style := psDot;
    inherited;
    Pen.Style    := aStyle;
    SelPen.Style := aSelStyle;
  end;
end;

procedure TLiveArc.RecalcTextCells;
begin
  inherited;
  if TextCells.Count>0 then
    TextCells[0].Left:=TextCells[0].Left-10;
end;

function TLiveArc.Transition(Sender : TCustomLiveBlock): boolean;
begin
  try
    Result:=DoTransition(Sender);
  except
    Result:=false; // Runtime Error in DoTransition
  end;
end;

{ TLiveBezier }

constructor TLiveBezier.Create(AOwner: TComponent);
begin
  inherited;
  TargetArrow.Shape:=asSolidArrow;
end;

function TLiveBezier.DoTransition(Sender : TCustomLiveBlock): boolean;
begin
  if Assigned(FOnTransition) then
    Result:=FOnTransition(Self,Sender)
  else
    Result:=false;
end;

procedure TLiveBezier.PaintControl(AInfo: TDiagramDrawInfo);
var
  aStyle, aSelStyle: TPenStyle;
begin
  if Assigned(SourceLinkPoint) and Assigned(SourceLinkPoint.Anchor) and
     SourceLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock) and
     Assigned(TargetLinkPoint) and Assigned(TargetLinkPoint.Anchor) and
     TargetLinkPoint.Anchor.InheritsFrom(TCustomLiveBlock)
  then
    inherited
  else
  begin
    // since CurPen function is not virtual, we need a little trick
    aStyle       := Pen.Style;
    aSelStyle    := SelPen.Style;
    Pen.Style    := psDot;
    SelPen.Style := psDot;
    inherited;
    Pen.Style    := aStyle;
    SelPen.Style := aSelStyle;
  end;
end;

procedure TLiveBezier.RecalcTextCells;
begin
  inherited;
  if TextCells.Count > 0 then
    TextCells[0].Left := TextCells[0].Left - 10;
end;

function TLiveBezier.Transition(Sender : TCustomLiveBlock): boolean;
begin
  try
    Result:=DoTransition(Sender);
  except
    Result:=false; // Runtime Error in DoTransition
  end;
end;

{ TExecuteThread }

destructor TExecuteThread.Destroy;
begin
  if FDiagram <> nil then
    FDiagram.ExecuteThread := nil;
  inherited;
end;

procedure TExecuteThread.DoFinish(aExitCode: integer);
begin
  FDiagram.FExitCode := aExitCode;
  //FDiagram.State := dsEdit; not thread-safe
  Terminate;
  {$WARNINGS OFF}
  if Suspended then Resume;
  {$WARNINGS ON}
end;

procedure TExecuteThread.Execute;
Var
  Start : dword;
  Delta : dword;
  Ratio : double;
  Time  : dword;

  procedure CalcTime;
  begin
    Delta := TimeGetTime - Start;
    Time:=Round(Delta*Ratio);
    if (FDiagram.MaximumIdle <> 0) and (Time > FDiagram.MaximumIdle) then
      Time := FDiagram.MaximumIdle;
  end;

begin
  with FDiagram do
  while not terminated do
  begin
    // Recalculate ratio every time to allow on-fly modifications
    Ratio := 2 * IdlePercent / 100;
    Start := TimeGetTime;
    Synchronize(ExecuteNode);
    CalcTime;

    if (FWaitState = wsNoWait) or (FWaitState = wsUndefined) then
    begin
      if StepMode then
      begin
        WaitForSingleObject(StepEvent, INFINITE);
        ResetEvent(StepEvent);
      end
      else
        sleep(Time);
    end;

    if not Terminated and (FRunError < 0) then
    Case FRunError of
      Sys_End_Program : // Request of terminating
         begin
           if LastNode.IsEndBlock then
             DoFinish(xNormal_termination)  // from End block
           else
             DoFinish(xProgram_termination);// from any block
         end;
      Sys_Broken_Link:
         DoFinish(xBroken_link);
      Sys_Invalid_Join:
         DoFinish(xInvalid_join);
      Sys_Err_Exception :
         DoFinish(xCode_Exception);
      Sys_Unhandled_Error:
         Synchronize(UnhandledRunError);
      else
         DoFinish(xUnknow_SysError);
    end;// case

    if not Terminated and (FRunError = 0) and (FWaitState = wsWaitAndSave) then
    begin
      DoFinish(xWaitState_termination);
    end;
  end;// while

  {Terminate subthreads}
  Synchronize(FDiagram.TerminateSubThreads);

  {wait for subthreads to finish}
  while FDiagram.FSubThreads.Count > 0 do;
end;

{ TDiagramThread }

constructor TDiagramThread.Create(aDiagram: TLiveDiagram);
begin
  FDiagram:=aDiagram;
  inherited create(true);
  FreeOnTerminate:=true;
end;

{ TVisualThread }

destructor TVisualThread.destroy;
begin
  if FDiagram <> nil then
    FDiagram.VisualThread := nil;
  inherited;
end;

procedure TVisualThread.Execute;
begin
  while not terminated do
  begin
    Synchronize(FDiagram.PaintExecute);
    Sleep(FDiagram.FSleepVisual);
  end;
end;

{ TLiveDiagram }

function TLiveDiagram.AcceptLink(ALink: TCustomDiagramLine; Anchor1,
  Anchor2: TLinkPoint): boolean;
begin
  Result:=inherited AcceptLink(ALink,Anchor1,Anchor2);

  if Result and Assigned(Anchor1) and Anchor1.DControl.InheritsFrom(TCustomLiveBlock) and (ALink.SourceLinkPoint.AnchorLink <> Anchor1) then
    Result:=TCustomLiveBlock(Anchor1.DControl).AcceptLink(ALink,Anchor1.index,ldOutput);

  if Result and Assigned(Anchor2) and Anchor2.DControl.InheritsFrom(TCustomLiveBlock) and (ALink.TargetLinkPoint.AnchorLink <> Anchor2) then
    Result:=TCustomLiveBlock(Anchor2.DControl).AcceptLink(ALink,Anchor2.index,ldInput);
end;

procedure TLiveDiagram.CMMouseEnter(var Message: TMessage);
begin
  If Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
end;

procedure TLiveDiagram.CMMouseLeave(var Message: TMessage);
begin
  If Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
end;

constructor TLiveDiagram.Create(AOwner: TComponent);
begin
  inherited;
  FCanResumeNext := true;
  FSubThreads := TList.Create;
  if not (csDesigning in ComponentState) then
    StepEvent := CreateEvent(nil, true, false, nil)
  else
    StepEvent := 0;
  FSleepVisual := 50;
  FIdlePercent := 30;
  FRunColor := clWhite;
  FLiveds := TList.Create;
  DragStyle := dsShape;
end;

destructor TLiveDiagram.Destroy;
begin
  if State <> dsEdit then
    DoForceStop;
  if StepEvent <> 0 then
    CloseHandle(StepEvent);
  FLiveds.Free;
  FSubThreads.Free;

  {this code is needed to avoid problems with threads. An issue happen if the diagram is destroyed
   in its OnTerminate event: the ExecuteThread is still being executed, but its reference to FDiagram
   is invalid. So, we will set it to nil here}
  if ExecuteThread <> nil then
    ExecuteThread.FDiagram := nil;
  if VisualThread <> nil then
    VisualThread.FDiagram := nil;
  inherited;
end;

procedure TLiveDiagram.DoAction(Action: TDiagramAction);

  procedure InitBlocks;
  Var
    c : integer;
  begin
    for c:=0 to FLiveds.Count-1 do
      Liveds[c].DoBeforeRun;
  end;

  procedure ActionRun(Paused : boolean; Continuation: boolean = false);
  begin
    case State of
      dsEdit :
         begin
           if PrepareRun then
           begin
             if not Continuation then
               InitBlocks;

             ExecuteThread := TExecuteThread.Create(self);
             ExecuteThread.OnTerminate := DoOnTerminate;

             DoReset(Continuation);
             if Continuation and (NextNode <> nil) and (LastNode <> nil) then
               DoOnStart(smContinue)
             else
             begin
               DoOnStart(smCold);
             end;

             if Paused then
             begin
               DoPause;
               {$WARNINGS OFF}
               ExecuteThread.Resume;
               {$WARNINGS ON}
             end
             else
               DoRun;
           end;
         end;
      dsPaused :
        begin
          DoOnStart(smWarm);
          DoRun;
        end;
    end;
  end;

begin
  if not (csDesigning in ComponentState) then
    Case Action of
      daRun :
        ActionRun(false);
      daRunPaused :
        ActionRun(true);
      daContinue:
        ActionRun(false, true);
      daContinuePaused:
        ActionRun(true, true);
      daPause :
        if FState = dsRunning then
          DoPause;
      daStop :
        if FState in [dsRunning, dsPaused] then
          DoStop(xUser_termination);
      daForceStop :
        if FState in [dsRunning, dsPaused] then
          DoForceStop;
      daReset :
        if FState = dsPaused then
          DoReset;
      daStep :
        if Fstate = dsPaused then DoStep
          else if Fstate = dsEdit then
            ActionRun(True);
    end;
end;

procedure TLiveDiagram.ForceTerminateSubThreads;
var
  c: integer;
  AList: TList;
begin
  AList := TList.Create;
  try
    for c := 0 to FSubThreads.Count - 1 do
      AList.Add(FSubThreads[c]);

    {$WARNINGS OFF}
    for c := 0 to AList.Count - 1 do
      TerminateThread(TForkThread(AList[c]).Handle, 0);
    {$WARNINGS ON}

    FSubThreads.Clear;
  finally
    AList.Free;
  end;
end;

procedure TLiveDiagram.DoForceStop;
begin
//  this will terminate the threads without triggering the events
//  should be used carefully and only when we are not completely
//  sure that all the resources are available (the main program
//  is destroing and the threads are active)
  if Assigned(ExecuteThread) then
  begin
    ForceTerminateSubThreads;
    TerminateThread(ExecuteThread.Handle, 0);
  end;
  ExecuteThread := nil;
  if Assigned(VisualThread) then
    TerminateThread(VisualThread.Handle,0);
  VisualThread := nil;
  FState := dsEdit;
end;

procedure TLiveDiagram.DoLoadState;
begin
  if Assigned(FOnLoadState) then
    FOnLoadState(Self);  
end;

procedure TLiveDiagram.DoOnChangeState;
begin
  if Assigned(FOnChangeState) then
    FOnChangeState(Self,FState);
end;

procedure TLiveDiagram.DoOnRunError(Block: TCustomLiveBlock;
  var Error: integer; var ResumeNext: boolean);
begin
  try
    if Assigned(FOnRunError) then
      FOnRunError(Self,Block,Error,ResumeNext)
    else
      Error:=xUnhandled_error;
  except
    Error:=Sys_Err_Exception;
    ResumeNext:=False;
  end;
end;

procedure TLiveDiagram.DoOnShift(OldBlock, NewBlock: TCustomLiveBlock);
begin
  if Assigned(FOnShift) then
    FOnShift(Self,OldBlock,NewBlock);
end;

procedure TLiveDiagram.DoOnStart(StartMode : TStartMode);
begin
  if Assigned(FOnStart) then
    FOnStart(self,StartMode);
end;

procedure TLiveDiagram.DoOnTerminate(Sender: TObject);
begin
  State := dsEdit;

  if LastNode <> nil then
    LastNode.ControlState := csRunOff;

  if FExitCode = xWaitState_Termination then
    SaveState;

  if Assigned(FOnTerminate) then
    FOnTerminate(self, FExitCode);

  {Do not put anything after this line, because the diagram itself might
   be destroyed in the OnTerminate event}
end;

procedure TLiveDiagram.DoPause;
begin
  ResetEvent(StepEvent);
  StepMode := true;
  State := dsPaused;
end;

procedure TLiveDiagram.DoReset(Continue: boolean = false);
begin
  TerminateSubThreads;
  if (LastNode = nil) or not Continue then
    LastNode := FStart;
  if (NextNode = nil) or not Continue then
    NextNode := FStart;
  ErrorNode := nil;
  FRunError := 0;
  FRunErrorMsg := '';
  FExitCode := 0;
  FCanResumeNext := true;
end;

procedure TLiveDiagram.DoRun;
begin
  StepMode := false;
  {$WARNINGS OFF}
  if ExecuteThread.Suspended then
    ExecuteThread.Resume;
  {$WARNINGS ON}
  SetEvent(StepEvent);
  State := dsRunning;
end;

procedure TLiveDiagram.DoSaveState;
begin
  if Assigned(FOnSaveState) then
    FOnSaveState(Self);
end;

procedure TLiveDiagram.DoStep;
begin
  StepMode := true;
  SetEvent(StepEvent);
end;

procedure TLiveDiagram.DoStop(TheExitCode : integer);
begin
  if StepMode then
  begin
    ExecuteThread.Terminate;
    StepMode := false;
    SetEvent(StepEvent);
    {$WARNINGS OFF}
    if ExecuteThread.Suspended then
      ExecuteThread.Resume;
    {$WARNINGS ON}
  end
  else
  begin
    KillThread(ExecuteThread);
  end;
  FExitCode := TheExitCode;
  DoOnTerminate(self);
  State := dsEdit;
end;

procedure TLiveDiagram.ExecuteNode;
Var
  FNext : TCustomLiveBlock;
  ExecInfo: TExecuteNodeInfo;
begin
  LastNode.ControlState := csRunOFF;
  NextNode.ControlState := csRunON;
  DoOnShift(LastNode,NextNode);

  ExecInfo.Error := 0;
  ExecInfo.Decision := 0;
  ExecInfo.ErrorMsg := '';
  ExecInfo.RealErrorNode := nil;
  ExecInfo.WaitState := wsUndefined;
  ExecInfo.Path := nil;
  ExecInfo.NextRunTime := 0;

  DoBeforeExecuteNode(NextNode);
  NextNode.ExecuteEx(ExecInfo);
  DoAfterExecuteNode(NextNode);

  FWaitState := ExecInfo.WaitState;
  FNext := ExecInfo.NextNode;
  FRunError := ExecInfo.Error;
  FRunErrorMsg := ExecInfo.ErrorMsg;

  //FNext := NextNode.Execute(FRunError, ADecision);

  LastNode:=NextNode;

  {$WARNINGS OFF}
  if (FRunError = Sys_Err_Exception) and ExecuteThread.Suspended then
    ExecuteThread.Resume;
  {$WARNINGS ON}

  if (FRunError > 0) and (LastNode = FErrorHandler) then
    FRunError := 0; // To avoid recursion

  if LastNode = FErrorHandler then
  begin
    if FRunError = 0 then // Error recovered
    begin
      if Assigned(FErrorHandler.FNext) then
        NextNode := FErrorHandler.FNext  // Error handler linked
      else
        if Assigned(ErrorNode) and Assigned(ErrorNode.Next) and FCanResumeNext then
          NextNode := ErrorNode.Next  // Resume Next
        else
        begin
          FRunError := Sys_Broken_Link;
          FCanResumeNext := true;
        end;
    end;
    if (FRunError = 0) and Assigned(ErrorNode) then
      ErrorNode.ControlState := csRunOFF;
    Exit;
  end;

  if (FRunError <> 0) and (FRunError <> Sys_End_Program) then
  begin
    {Get the exact error node that caused the exception among many possible execution paths}
    ErrorNode := ExecInfo.RealErrorNode;
    if ErrorNode = nil then
      ErrorNode := LastNode; 

    ErrorNode.ControlState := csRunERR;

    if FRunError > 0 then
    begin
      if Assigned(FErrorHandler) then
        NextNode := FErrorHandler
      else
        FRunError := Sys_Unhandled_Error;
    end;
  end
  else
    NextNode:=FNext;
end;

function TLiveDiagram.GetLived(index: integer): TCustomLiveBlock;
begin
{$WARNINGS OFF}
  Result:=TCustomLiveBlock(FLiveds[index]);
{$WARNINGS ON}
end;

function TLiveDiagram.Link: boolean;
Var
  c : integer;
  aBlock : TCustomLiveBlock;

  procedure ShowError(const msg : string);
  begin
    MessageDlg(msg,mtError,[mbOk],0);
  end;

  function IsWire(aLink : TCustomDiagramLine) : boolean;
  begin
    Result:=(aLink is TLiveWire) or
            (aLink is TLiveSideWire) or
            (aLink is TLiveArc) or
            (aLink is TLiveBezier);
  end;


begin
  FStart := nil;
  FEnd := nil;
  FErrorHandler := nil;
  Linked := false;
  Result := false;
  FLiveds.Clear;
  UnselectAll;

  {Build state list for all blocks. It must be done before calling Link method for any block}
  for c := 0 to BlockCount-1 do
    if Blocks[c].InheritsFrom(TCustomLiveBlock) then
      TCustomLiveBlock(Blocks[c]).BuildStateList;

  {Now iterate all blocks}
  for c:=0 to BlockCount-1 do
  begin
    if Blocks[c].InheritsFrom(TCustomLiveBlock) then
    begin
      aBlock:=TCustomLiveBlock(Blocks[c]);
      FLiveds.Add(aBlock);
      //----------------------------------------------
      if aBlock.IsStartBlock then
      begin
        if Assigned(FStart) then
        begin
          aBlock.Selected:=true;
          ShowError('Duplicate Start block : '+aBlock.Name);
          exit;
        end
        else
          FStart := aBlock;
      end;
      //----------------------------------------------
      if aBlock.IsEndBlock then
      begin
        if Assigned(FEnd) then
        begin
          aBlock.Selected:=true;
          ShowError('Duplicate End block : '+aBlock.Name);
          exit;
        end
        else
          FEnd := aBlock;
      end;
      //----------------------------------------------
      if aBlock.IsErrorHandler then
      begin
        if Assigned(FErrorHandler) then
        begin
          aBlock.Selected:=true;
          ShowError('Duplicate Error handler : '+aBlock.Name);
          exit;
        end
        else
         FErrorHandler := aBlock;
      end;
      //----------------------------------------------
      if not aBlock.PassThrough then
      begin
        if not aBlock.Link then
        begin
          aBlock.Selected:=true;
          ShowError('Link error in '+aBlock.Name);
          exit;
        end;
      end;
    end;
  end;

  if FStart=nil then
  begin
    ShowError('Missing Start block');
    exit;
  end;
  if FEnd=nil then
  begin
    ShowError('Missing End block');
    exit;
  end;
  Result:=true;
  linked:=true;
end;

procedure TLiveDiagram.Modified;
begin
  inherited;
  Linked := false;
end;

procedure TLiveDiagram.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
  if (FState=dsEdit) or (csDesigning in ComponentState) then
   inherited;
end;

procedure TLiveDiagram.PaintExecute;
Var
  c : integer;
begin
  BeginUpdate;
  for c:=0 to FLiveds.Count-1 do
    Liveds[c].ShowState;
  EndUpdate;
end;

function TLiveDiagram.PrepareRun: boolean;
begin
// override this method to perform additional operations
  UnselectAll;
  if Linked then
    Result:=true
  else
    Result:=Link;
end;

procedure TLiveDiagram.LoadNextNodeProp(Reader: TReader);
begin
  FNextNodeStr := Reader.ReadString;
end;

procedure TLiveDiagram.StoreNextNodeProp(Writer: TWriter);
begin
  if NextNode <> nil then
    Writer.WriteString(NextNode.Name)
  else
    Writer.WriteString('');
end;

procedure TLiveDiagram.LoadLastNodeProp(Reader: TReader);
begin
  FLastNodeStr := Reader.ReadString;
end;

procedure TLiveDiagram.StoreLastNodeProp(Writer: TWriter);
begin
  if LastNode <> nil then
    Writer.WriteString(LastNode.Name)
  else
    Writer.WriteString('');
end;

procedure TLiveDiagram.LoadErrorNodeProp(Reader: TReader);
begin
  FErrorNodeStr := Reader.ReadString;
end;

procedure TLiveDiagram.StoreErrorNodeProp(Writer: TWriter);
begin
  if ErrorNode <> nil then
    Writer.WriteString(ErrorNode.Name)
  else
    Writer.WriteString('');
end;

procedure TLiveDiagram.LoadRunErrorMsgProp(Reader: TReader);
begin
  FRunErrorMsg := Reader.ReadString;
end;

procedure TLiveDiagram.StoreRunErrorMsgProp(Writer: TWriter);
begin
  Writer.WriteString(FRunErrorMsg);
end;

procedure TLiveDiagram.DefineProperties(Filer: TFiler);
begin
  inherited; { allow base classes to define properties }
  Filer.DefineProperty('NextNode', LoadNextNodeProp, StoreNextNodeProp, FSavingState);
  Filer.DefineProperty('LastNode', LoadLastNodeProp, StoreLastNodeProp, FSavingState);

  //Filer.DefineProperty('RunError', LoadRunErrorProp, StoreRunErrorProp, FRunError <> 0);
  Filer.DefineProperty('RunErrorMsg', LoadRunErrorMsgProp, StoreRunErrorMsgProp, FRunError <> 0);
  Filer.DefineProperty('ErrorNode', LoadErrorNodeProp, StoreErrorNodeProp, FRunError <> 0);
end;

procedure TLiveDiagram.Loaded;

  function FindBlock(AName: string): TCustomLiveBlock;
  var
    c: integer;
  begin
    result := nil;
    if AName <> '' then
      for c := 0 to DControlCount - 1 do
        if (DControls[c] is TCustomLiveBlock) and SameText(DControls[c].Name, AName) then
        begin
          result := TCustomLiveBlock(DControls[c]);
          break;
        end;
  end;

begin
  inherited;
  NextNode := FindBlock(FNextNodeStr);
  LastNode := FindBlock(FLastNodeStr);
  ErrorNode := FindBlock(FErrorNodeStr);
end;

procedure TLiveDiagram.LoadState;
begin
  DoLoadState;
end;

procedure TLiveDiagram.SaveState;
begin
  DoSaveState;
end;

procedure TLiveDiagram.LoadStateFromStream(AStream: TStream; TextFormat: boolean = false);
begin
  FSavingState := true;
  try
    LoadFromStream(AStream, TextFormat);
  finally
    FSavingState := false;
  end;
end;

procedure TLiveDiagram.SaveStateToStream(AStream: TStream; TextFormat: boolean = false);
begin
  FSavingState := true;
  try
    SaveToStream(AStream, TextFormat);
  finally
    FSavingState := false;
  end;
end;

procedure TLiveDiagram.SetFIdlePercent(const Value: dword);
begin
  FIdlePercent := Value;
end;

procedure TLiveDiagram.SetFRunColor(const Value: TColor);
begin
  if FRunColor <> Value then
  begin
    FRunColor := Value;
    invalidate;
  end;
end;

procedure TLiveDiagram.SetFSleepVisual(const Value: dword);
begin
  if FSleepVisual <> Value then
  begin
    FSleepVisual := Value;
  end;
end;

procedure TLiveDiagram.SetFState(const Value: TDiagramState);

  procedure SetForkControlState(AForkBlock: TLiveForkBlock);
  var
    c: integer;
  begin
    for c := 0 to AForkBlock.FPaths.Count - 1 do
      if AForkBlock.FPaths[c].FNextNode <> nil then
      begin
        if AForkBlock.FPaths[c].FNextNode is TLiveForkBlock then
          SetForkControlState(TLiveForkBlock(AForkBlock.FPaths[c].FNextNode))
        else
          AForkBlock.FPaths[c].FNextNode.ControlState := csRunOn;
      end;
  end;

  procedure SetControlState(aState : TControlState; AShowNextNode: boolean = false);
  Var
    c: integer;

  begin
    BeginUpdate;
    {put everything in edit/view state}
    for c := 0 to FLiveds.Count - 1 do
    begin
      Liveds[c].ControlState := aState;
    end;

    {if it's dsView state, then indicates the nodes that are to be executed}
    if AShowNextNode then
    begin
      Case ViewStateMode of
        vmStart:
          if FStart <> nil then
            FStart.ControlState := csRunOn;  
        vmEnd:
          if FEnd <> nil then
            FEnd.ControlState := csRunOn;
      else {vmRun}
        begin
          if (NextNode <> nil) then
          begin
            if NextNode is TLiveForkBlock then
              SetForkControlState(TLiveForkBlock(NextNode))
            else
              NextNode.ControlState := csRunOn;
          end;
        end;
      end;
    end;
    EndUpdate;
  end;

begin
  //if FState <> Value then
  begin
    if (FState = dsEdit) or (FState = dsView) then
    begin
      FStoreColor:=Color;
      FStoreShowLinkPts:=ShowLinkPoints;
      FStoreSnapGrid := SnapGrid.Visible;
    end;

    Case Value of
      dsEdit:
        begin
          KillThread(VisualThread);
          SetControlState(csEdit, false);
          ShowLinkPoints := FStoreShowLinkPts;
          SnapGrid.Visible := FStoreSnapGrid;
          Color := FStoreColor;
        end;
      dsView:
        begin
          if not Linked then Link;
          KillThread(VisualThread);
          SetControlState(csEdit, true);
          ShowLinkPoints := false;
          SnapGrid.Visible := false;
          Color := FStoreColor;
          PaintExecute;
        end;
    else
      begin
        Color := FRunColor;
        ShowLinkPoints := false;
        SnapGrid.Visible := false;
        if FSleepVisual > 0 then
        begin
          SetControlState(csRunOFF);
          VisualThread := TVisualThread.Create(self);
          {$WARNINGS OFF}
          VisualThread.Resume;
          {$WARNINGS ON}
        end
        else
          VisualThread := nil;
      end;
    end;
    FState := Value;
    DoOnChangeState;
  end;
end;

procedure TLiveDiagram.UnhandledRunError;
Var
  ResumeNext : boolean;
  aExitCode  : integer;

  procedure DoTerminate(aExitCode : integer);
  begin
    FExitCode := aExitCode;
    ExecuteThread.Terminate;
    {$WARNINGS OFF}
    if ExecuteThread.Suspended then
      ExecuteThread.Resume;
    {$WARNINGS ON}
    State := dsEdit;
  end;

begin
  ResumeNext := false;
  aExitCode := FRunError;
  DoOnRunError(ErrorNode, aExitCode, ResumeNext);

  if ResumeNext then
  begin
    NextNode := ErrorNode.Next;
    if Assigned(NextNode) and FCanResumeNext then
      FRunError := 0
    else
    begin
      DoTerminate(xBroken_Link);
      FCanResumeNext := true;
    end;
  end
  else
    DoTerminate(xUnhandled_error);
end;

procedure TLiveDiagram.TerminateSubThreads;
var
  c: integer;
  AList: TList;
begin
  AList := TList.Create;
  try
    for c := 0 to FSubThreads.Count - 1 do
      AList.Add(FSubThreads[c]);

    {$WARNINGS OFF}
    for c := 0 to AList.Count - 1 do
      KillThread(TForkThread(aList[c]));
    {$WARNINGS ON}
  finally
    AList.Free;
  end;
end;

procedure TLiveDiagram.MakeActiveNodeVisible;
var
  c: integer;
  Node: TCustomLiveBlock;
begin
  Node := nil;
  for c := 0 to FLiveds.Count - 1 do
  begin
    if Liveds[c].ControlState = csRunOn then
    begin
      Node := Liveds[c];

      {if the node is not a fork block, then break the for, because it
       can already be displayed. Otherwise, continue looking until it reaches
       a non-fork block. If nothing more is found, it will use the fork block anyway}
      if not (Node is TLiveForkBlock) then
        break;
    end;
  end;

  if Node <> nil then
    Node.MakeVisible;
end;

function TLiveDiagram.DiagramStreamClass: TatDiagramClass;
begin
  result := TLiveStreamDiagram;
end;

procedure TLiveDiagram.DoAfterExecuteNode(ANode: TCustomLiveBlock);
begin

end;

procedure TLiveDiagram.DoBeforeExecuteNode(ANode: TCustomLiveBlock);
begin

end;

{ TLiveForkBlock }

function TLiveForkBlock.AcceptLink(ALink: TCustomDiagramLine;
  LinkIndex: integer; Direction: TLinkDirection): boolean;
begin
  result := true;
end;

constructor TLiveForkBlock.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 40;
  Height := 32;
  OriginalRect := Square(0, 0, 100, 80);
  UpdateLinkPoints;
  UpdateBlockHandles;
  Restrictions := Restrictions + [crNoResize];
  FPaths := TExecutionPaths.Create(Self, TExecutionPath);
  FSubThreads := TList.Create;
end;

destructor TLiveForkBlock.Destroy;
begin
  FPaths.Free;
  FSubThreads.Free;
  inherited;
end;

function TLiveForkBlock.AllPathsTerminatedOk: boolean;
var
  c: integer;
begin
  result := true;
  for c := 0 to FPaths.Count - 1 do
    if not (FPaths[c].FFinished and (
      (FPaths[c].FExitCode = xPath_Termination) or (FPaths[c].FExitCode = xWaitState_Termination))) then
    begin
      result := false;
      exit;
    end;
end;

procedure TLiveForkBlock.ExecuteEx(var ExecInfo: TExecuteNodeInfo);
var
  c: integer;
  BaseNextBlock: TCustomLiveBlock;
  ShouldWait: boolean;
begin
  {if not Continuation then
   InitBlocks;}

  if not FThreadsCreated then
  begin
    for c := 0 to FPaths.Count - 1 do
    begin
      {Create a new execution path thread, but only for new paths(exit code = 0)
       or for paths that were loaded (exit code = xWaitState_Termination)}
      if (FPaths[c].FExitCode = 0) or (FPaths[c].FExitCode = xWaitState_Termination) then
      begin
        FPaths[c].FFinished := false;
        FPaths[c].FParentPath := ExecInfo.Path;
        DoPathStart(FPaths[c]);
        FPaths[c].FExecuteThread := TForkThread.Create(FPaths[c]);
        FPaths[c].Diagram.FSubThreads.Add(FPaths[c].FExecuteThread);
        FSubThreads.Add(FPaths[c].FExecuteThread);
        FPaths[c].FExecuteThread.OnTerminate := FPaths[c].OnTerminateForkThread;
        {$WARNINGS OFF}
        if FPaths[c].FExecuteThread.Suspended then
          FPaths[c].FExecuteThread.Resume;
        {$WARNINGS ON}
      end;
    end;
    FThreadsCreated := true;
  end;

  {By default, the next node is the node itself.
   We will check all current paths being executed, and if all have been terminated and reached the same join block,
   then the next block will be the very next after the join block.}
  ExecInfo.NextNode := Self;

  {Now check all current paths being executed}
  if AllPathsTerminatedOk then
  begin
    {Find the next block of all threads and see if it's the same block}
    BaseNextBlock := nil;
    ShouldWait := false;
    for c := 0 to FPaths.Count - 1 do
    begin
      {if one or more execution paths were finished with waitstate_termination code, then
       the fork block must return as waitandsave}
      if FPaths[c].FExitCode = xWaitState_Termination then
        ShouldWait := true
      else
      begin
        {if the exit code is normal, then check the join block reached by the execution path.
         All join blocks must be the same. We don't check for paths that had xWaitState_Termination,
         because the can end in any block, it does not need to be a join block}

        {BaseNextBlock will be set to the first block of the list}
        if BaseNextBlock = nil then
          BaseNextBlock := FPaths[c].FNextNode;

        {Now check if the next block is the same of the basenextblock}
        if BaseNextBlock <> FPaths[c].FNextNode then
        begin
          {if it's different, then an error should be raised}
          TLiveDiagram(Diagram).FCanResumeNext := false;
          ExecInfo.Error := Sys_Invalid_Join;
          ExecInfo.ErrorMsg := 'Parallel execution paths ended at different points. They should end in the same join block.';
          Exit;
        end;
      end;
    end;

    ExecInfo.NextNode := BaseNextBlock;
    if ShouldWait then
    begin
      ExecInfo.NextNode := Self;
      ExecInfo.WaitState := wsWaitAndSave;
    end;

    FThreadsCreated := false;
  end
  else
  if FErrorPath <> nil then
  begin
    TLiveDiagram(Diagram).FCanResumeNext := false;
    ExecInfo.Error := FErrorPath.FRunError;
    ExecInfo.ErrorMsg := FErrorPath.FRunErrorMsg;
    ExecInfo.RealErrorNode := FErrorPath.FErrorNode;
    FErrorPath := nil;
  end;
end;

function TLiveForkBlock.Link: boolean;
var
  c: integer;
  NewPath: TExecutionPath;
begin
  result := (PreviousStates.Count > 0) and (NextStates.Count > 0);

  {Check for correct path - all paths must lead to the same join block}
  result := result and ForkLinkIsOk;

  {if link is ok, then create the execution path collection items for each next state.
   This will not change until the diagram is modified again}
  if result then
  begin
    {We must do an algorithm that keeps the current FPaths collection, in order to allow
     state loading.}

    {Flag all paths to false}
    for c := 0 to FPaths.Count - 1 do
      FPaths[c].FDeleteFlag := true;

    {iterate through all states to create/modify the current path}
    for c := 0 to NextStates.Count - 1 do
    begin
      {check if the path already exists. If not, then create it. In either case it will be flagged as false
       so it will not be deleted}
      NewPath := FPaths.FindStart(NextStates.Block[c]);
      if NewPath = nil then
      begin
        {Create a new execution path}
        NewPath := FPaths.Add;
        NewPath.FStartNode := NextStates.Block[c];
      end;

      {Flag the path to true}
      NewPath.FDeleteFlag := false;
    end;

    {Delete all paths flagged as true}
    c := 0;
    while c <= FPaths.Count - 1 do
    begin
      if FPaths[c].FDeleteFlag then
        FPaths[c].Free
      else
        inc(c);
    end;
  end;
end;

type
  TCheckedBlock = class(TCollectionItem)
  private
    Block: TCustomLiveBlock;
    Join: TCustomLiveBlock;
    Checked: boolean;
  end;

  TCheckedBlocks = class(TCollection)
  private
    function GetItem(Index: integer): TCHeckedBlock;
    function Add: TCheckedBlock;
    function Find(aBlock: TCustomLiveBlock): TCheckedBlock;
  end;

  function TCheckedBlocks.Add: TCheckedBlock;
  begin
    result := TCheckedBlock(inherited Add);
  end;

  function TCheckedBlocks.GetItem(Index: integer): TCHeckedBlock;
  begin
    result := TCheckedBlock(inherited Items[Index]);
  end;

  function TcheckedBlocks.Find(aBlock: TCustomLiveBlock): TCheckedBLock;
  var
    c: integer;
  begin
    result := nil;
    for c := 0 to Count - 1 do
      if GetItem(c).Block = aBlock then
      begin
        result := GetItem(c);
        exit;
      end;
  end;


function TLiveForkBlock.ForkLinkIsOk: boolean;
var
  BlockList: TCheckedBlocks;

  function FindJoinBlock(ABlock: TCustomLiveBlock): TCustomLiveBlock;
  var
    c: integer;
    Join: TCustomLiveBlock;
    NextBlock: TCustomLiveBlock;
    CheckedBlock: TCheckedBlock;
    FoundCheckedBlock: TCheckedBlock;
    IgnoreChecking: boolean;
  begin
    {Save a list of analised block to avoid recursion}
    CheckedBlock := BlockList.Add;
    CheckedBlock.Block := aBlock;
    Join := nil;

    {iterate through all next states and find the join block}
    result := nil;
    for c := 0 to ABlock.NextStates.Count - 1 do
    begin
      NextBlock := ABlock.NextStates.Block[c];

      {Only check blocks which are not in the block list, to avoid recursion.
       If the block is in the block list already, there is no need to check the join block}
      FoundCheckedBlock := BlockList.Find(NextBlock);
      IgnoreChecking := Assigned(FoundCheckedBlock) and not FoundCheckedBlock.Checked;

      if not IgnoreChecking then
      begin
        {Find the next join block}
        if Assigned(FoundCheckedBlock) and FoundCheckedBlock.Checked then
          Join := FoundCheckedBlock.Join
        else
          if NextBlock is TLiveJoinBlock then
            Join := NextBlock
          else
          begin
            Join := FindJoinBlock(NextBlock);
            if (NextBlock is TLiveForkBlock) and (Join <> nil) then
              Join := FindJoinBlock(Join);
          end;

        {If the join is nil, then there is an error, return with result nil}
        if Join = nil then
        begin
          result := nil;
          exit;
        end else
        begin
          {if result is nil it means that it's the first iteration, so there is no need to check if
           it's different or equal other joins from other next states. }
          if result = nil then
            result := Join
          else
          begin
            {Now we must check the Join found. All states must lead to the same join}
            if (Join <> result) then
            begin
              result := nil;
              exit;
            end;
          end;
        end;
      end;
    end;

    CheckedBlock.Join := Join;
    CheckedBlock.Checked := true;
  end;

begin
  BlockList := TCheckedBlocks.Create(TCheckedBlock);
  try
    result := FindJoinBlock(Self) <> nil;
  finally
    BlockList.Free;
  end;
end;

procedure TLiveForkBlock.DoBeforeRun;
var
  c: integer;
begin
  inherited;
  FThreadsCreated := false;
  FErrorPath := nil;

  for c := 0 to FPaths.Count - 1 do
  begin
    FPaths[c].FExitCode := 0;
    FPaths[c].FRunError := 0;
    FPaths[c].FRunErrorMsg := '';
    FPaths[c].FErrorNode := nil;
    FPaths[c].FLastNode := FPaths[c].FStartNode;
    FPaths[c].FNextNode := FPaths[c].FStartNode;
  end;
end;

procedure TLiveForkBlock.DoPathStart(APath: TExecutionPath);
begin
end;

procedure TLiveForkBlock.DoPathTerminate(APath: TExecutionPath);
begin
end;

procedure TLiveForkBlock.TerminateSubThreads;
var
  c: integer;
  AList: TList;
begin
  AList := TList.Create;
  try
    for c := 0 to FSubThreads.Count - 1 do
      AList.Add(FSubThreads[c]);

    {$WARNINGS OFF}
    for c := 0 to AList.Count - 1 do
      KillThread(TForkThread(aList[c]));
    {$WARNINGS ON}
  finally
    AList.Free;
  end;
end;

procedure TLiveForkBlock.Loaded;

  function FindBlock(AName: string): TCustomLiveBlock;
  var
    c: integer;
  begin
    result := nil;
    with Diagram do
    begin
      for c := 0 to DControlCount - 1 do
        if (DControls[c] is TCustomLiveBlock) and SameText(DControls[c].Name, AName) then
        begin
          result := TCustomLiveBlock(DControls[c]);
          break;
        end;
    end;
  end;

var
  c: integer;
begin
  inherited;

  FThreadsCreated := false;
  for c := 0 to FPaths.Count - 1 do
  begin
    FPaths[c].FNextNode := FindBlock(FPaths[c].FNextNodeStr);
    FPaths[c].FLastNode := FindBlock(FPaths[c].FLastNodeStr);
    FPaths[c].FStartNode := FindBlock(FPaths[c].FStartNodeStr);
  end;
end;

procedure TLiveForkBlock.DefineProperties(Filer: TFiler);
var
  HasData: boolean;
begin
  inherited;
  HasData := Assigned(Diagram) and (Diagram is TLiveDiagram) and (TLiveDiagram(Diagram).SavingState);
  Filer.DefineProperty('Paths', LoadPathsProp, StorePathsProp, HasData);
end;

procedure TLiveForkBlock.LoadPathsProp(Reader: TReader);
begin
  Reader.ReadValue;
  Reader.ReadCollection(FPaths);
end;

procedure TLiveForkBlock.StorePathsProp(Writer: TWriter);
begin
  Writer.WriteCollection(FPaths);
end;

procedure TLiveForkBlock.UpdateLinkPoints;
begin
  LinkPoints.Clear;
  with Drawer.OriginalRect do
  begin
    LinkPoints.Add((Right - Left) / 2, Top, aoUp);
    LinkPoints.Add(Left, Bottom, aoDown);
    LinkPoints.Add(Right, Bottom, aoDown);
  end;
end;

procedure TLiveForkBlock.DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo);
var
  pc: TColor;
  path: TDgrGraphicsPath;
begin
  if PathDrawingMode then
  begin
    path := AInfo.DgrDrawer.CreatePath;
    try
      path.Reset;
      path.AddLine(50, 0, 50, 30);
      path.AddLine(100, 80, 50, 30);
      path.AddLine(0, 80, 50, 30);
      AInfo.DgrDrawer.TransformPath(path);
      AInfo.DgrDrawer.Canvas.DrawPath(path);
    finally
      path.Free;
    end;
  end
  else
  begin
    DrawCrossHairs(AInfo.Canvas, ABlockInfo.Rect);
    with AInfo.Canvas, AInfo.Drawer do
    begin
      pc := Pen.Color;
      Pen.Color := Self.Pen.Color;
      AutoMoveTo(50, 0);
      AutoLineTo(50, 30);
      AutoLineTo(0, 80);
      AutoMoveTo(50, 30);
      AutoLineTo(100, 80);
      Pen.Color:=pc;
    end;
  end;
end;

{function TLiveForkBlock.BlockPolygon: TPointArray;
begin

end;}


{ TForkThread }

constructor TForkThread.Create(aPath: TExecutionPath);
begin
  FPath := aPath;
  inherited Create(true);
  FreeOnTerminate := true;
end;

destructor TForkThread.Destroy;
begin
  FPath.FExecuteThread := nil;
  inherited;
end;

procedure TForkThread.DoFinish(aExitCode: integer);
begin
  FPath.FExitCode := aExitCode;
  Terminate;
  {$WARNINGS OFF}
  if Suspended then Resume;
  {$WARNINGS ON}
end;

procedure TForkThread.Execute;
Var
  Start : dword;
  Delta : dword;
  Ratio : double;
  Time  : dword;

  procedure CalcTime;
  begin
    Delta := TimeGetTime - Start;
    Time := Round(Delta * Ratio);
  end;

begin
  while not terminated do
  begin
    // Recalculate ratio every time to allow on-fly modifications
    Ratio := 2 * 30 / 100;
    Start := TimeGetTime;
    Synchronize(FPath.ExecuteNode);
    CalcTime;

    if (FPath.FWaitState = wsNoWait) or (FPath.FWaitState = wsUndefined) then
    begin
      if FPath.Diagram.StepMode then
      begin
        WaitForSingleObject(FPath.Diagram.StepEvent, INFINITE);
        ResetEvent(FPath.Diagram.StepEvent);
      end
      else
        sleep(Time);
    end;

    if not Terminated and (FPath.FRunError < 0) then
      Case FPath.FRunError of
        Sys_End_Program : // Request of terminating
           begin
             {if LastNode.IsEndBlock then //It does not make sense to reach an EndBlock from an execution path
               DoFinish(xNormal_termination)
             else}
             DoFinish(xProgram_termination);// from any block
           end;
        {Sys_Broken_Link: //Sys_Broken_Link does not make sense in execution paths
           DoFinish(xBroken_link);}

        //Code below is commented between (* *) because the "else" part of the case block already propagates
        //the internal Sys error
        (*Sys_Err_Exception :
           DoFinish(Sys_Err_Exception);
        Sys_Invalid_Join:
           DoFinish(Sys_Invalid_Join);*)

        {Sys_Unhandled_Error: //Sys_Unhandled_Error does not make sense in execution path because errors are handled in main threads
           Synchronize(UnhandledRunError);}
        Sys_End_Path:
           DoFinish(xPath_termination);
      else
        {Propagate the error}
        DoFinish(FPath.FRunError);
      end;// case

    if not Terminated and (FPath.FRunError > 0) then
    begin
      DoFinish(FPath.FRunError);
    end;

    if not Terminated and (FPath.FRunError = 0) and (FPath.FWaitState = wsWaitAndSave) then
    begin
      DoFinish(xWaitState_termination);
    end;

  end;// while
end;

{ TLiveJoinBlock }

function TLiveJoinBlock.AcceptLink(ALink: TCustomDiagramLine;
  LinkIndex: integer; Direction: TLinkDirection): boolean;
begin
  Result := ((Direction = ldOutput) and (Anchoreds(ldOutput) = 0)) or (Direction = ldInput)
end;

constructor TLiveJoinBlock.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 40;
  Height := 32;
  OriginalRect := Square(0, 0, 100, 80);
  Restrictions := Restrictions + [crNoResize];
  UpdateLinkPoints;
  UpdateBlockHandles;
end;

procedure TLiveJoinBlock.DrawShape(AInfo: TDiagramDrawInfo; ABlockInfo: TDiagramDrawBlockInfo);
var
  pc: TColor;
  path: TDgrGraphicsPath;
begin
  if PathDrawingMode then
  begin
    path := AInfo.DgrDrawer.CreatePath;
    try
      path.Reset;
      path.AddLine(50, 80, 50, 50);
      path.AddLine(0, 0, 50, 50);
      path.AddLine(100, 0, 50, 50);
      AInfo.DgrDrawer.TransformPath(path);
      AInfo.DgrDrawer.Canvas.DrawPath(path);
    finally
      path.Free;
    end;
  end
  else
  begin
    DrawCrossHairs(AInfo.Canvas, ABlockInfo.Rect);
    with AInfo.Canvas, AInfo.Drawer do
    begin
      pc := Pen.Color;
      Pen.Color := Self.Pen.Color;
      AutoMoveTo(50, 80);
      AutoLineTo(50, 50);
      AutoLineTo(0, 0);
      AutoMoveTo(50, 50);
      AutoLineTo(100, 0);
      Pen.Color:=pc;
    end;
  end;
end;

procedure TLiveJoinBlock.ExecuteEx(var ExecInfo: TExecuteNodeInfo);
begin
  inherited ExecuteEx(ExecInfo);
  if ExecInfo.Error = 0 then
    ExecInfo.Error := Sys_End_Path;
end;

function TLiveJoinBlock.Link: boolean;
begin
  result := inherited Link;
end;

procedure TLiveJoinBlock.UpdateLinkPoints;
begin
  LinkPoints.Clear;
  with Drawer.OriginalRect do
  begin
    LinkPoints.Add(Left, Top, aoUp);
    LinkPoints.Add(Right, Top, aoUp);
    LinkPoints.Add((Right - Left) / 2, Bottom, aoDown);
  end;
end;

{ TExecutionPaths }

function TExecutionPaths.Add: TExecutionPath;
begin
  result := TExecutionPath(inherited Add);
end;

function TExecutionPaths.Block: TLiveForkBlock;
begin
  result := TLiveForkBlock(GetOwner);
end;

function TExecutionPaths.FindStart(
  aBlock: TCustomLiveBlock): TExecutionPath;
var
  c: integer;
begin
  result := nil;
  for c := 0 to Count - 1 do
    if Items[c].FStartNode = aBlock then
    begin
      result := Items[c];
      Exit;
    end;
end;

function TExecutionPaths.GetItem(Index: integer): TExecutionPath;
begin
  result := TExecutionPath(inherited Items[Index]);
end;

{ TExecutionPath }

function TExecutionPath.Diagram: TLiveDiagram;
begin
  if (Paths <> nil) and (Paths.Block <> nil) then
    result := TLiveDiagram(Paths.Block.Diagram)
  else
    result := nil;
end;

procedure TExecutionPath.DoOnShift(OldBlock, NewBlock: TCustomLiveBlock);
begin
  if Diagram <> nil then
    Diagram.DoOnShift(OldBlock, NewBlock);
end;

procedure TExecutionPath.ExecuteNode;
Var
  FNext : TCustomLiveBlock;
  ExecInfo: TExecuteNodeInfo;
begin
  FLastNode.ControlState := csRunOFF;
  FNextNode.ControlState := csRunON;
  DoOnShift(FLastNode, FNextNode);

  ExecInfo.Error := 0;
  ExecInfo.ErrorMsg := '';
  ExecInfo.RealErrorNode := nil;
  ExecInfo.Decision := 0;
  ExecInfo.WaitState := wsUndefined;
  ExecInfo.Path := Self;
  ExecInfo.NextRunTime := 0;

  if Diagram <> nil then
    Diagram.DoBeforeExecuteNode(FNextNode);
  FNextNode.ExecuteEx(ExecInfo);
  if Diagram <> nil then
    Diagram.DoAfterExecuteNode(FNextNode);

  FWaitState := ExecInfo.WaitState;
  FNext := ExecInfo.NextNode;
  FRunError := ExecInfo.Error;
  FRunErrorMsg := ExecInfo.ErrorMsg;

  FLastNode := FNextNode;

  {$WARNINGS OFF}
  if (FRunError = Sys_Err_Exception) and FExecuteThread.Suspended then
    FExecuteThread.Resume;
  {$WARNINGS ON}

  if (FRunError <> 0) and (FRunError <> Sys_End_Program) and (FRunError <> Sys_End_Path) then
  begin
    {Get the exact error node that caused the exception among many possible execution paths}
    FErrorNode := ExecInfo.RealErrorNode;
    if FErrorNode = nil then
      FErrorNode := FLastNode;

    FErrorNode.ControlState := csRunERR;
  end
  else
    FNextNode := FNext;
end;

function TExecutionPath.GetLastNodeStr: string;
begin
  if FLastNode <> nil then
    Result := FLastNode.Name
  else
    Result := '';
end;

function TExecutionPath.GetNextNodeStr: string;
begin
  if FNextNode <> nil then
    Result := FNextNode.Name
  else
    Result := '';
end;

function TExecutionPath.GetStartNodeStr: string;
begin
  if FStartNode <> nil then
    Result := FStartNode.Name
  else
    Result := '';
end;

procedure TExecutionPath.OnTerminateForkThread(Sender: TObject);
begin
  if FLastNode <> nil then
    FLastNode.ControlState := csRunOff;

  FFinished := true;
  Diagram.FSubThreads.Remove(FExecuteThread);
  Paths.Block.FSubThreads.Remove(FExecuteThread);

  if (FExitCode <> xPath_Termination) and (FExitCode <> xWaitState_Termination) and (FExitCode <> 0) then
  begin
    Paths.Block.FErrorPath := Self;
    Paths.Block.TerminateSubThreads;
  end;

  Paths.Block.DoPathTerminate(Self);
end;

function TExecutionPath.Paths: TExecutionPaths;
begin
  result := TExecutionPaths(Collection);
end;

{ TLiveStreamDiagram }

constructor TLiveStreamDiagram.Create(Owner: TComponent);
begin
  inherited;
  SetBounds(0, 0, 0, 0);
end;

procedure TLiveStreamDiagram.PaintWindow(DC: HDC);
begin
end;

procedure TLiveStreamDiagram.WMNCPaint(var Message: TMessage);
begin
end;

initialization
  RegisterDControl(TLiveConnectorSource, '', 'Source connector', 'Live Diagram');
  RegisterDControl(TLiveConnectorTarget, '', 'Target connector', 'Live Diagram');
  RegisterDControl(TLiveLineJoin, '', 'Line Jointer', 'Live Diagram');
  RegisterDControl(TLiveWire, '', 'Live Wire', 'Live Diagram');
  RegisterDControl(TLiveSideWire, '', 'Live Side Wire', 'Live Diagram');
  RegisterDControl(TLiveArc, '', 'Live Arc', 'Live Diagram');
  RegisterDControl(TLiveBezier, '', 'Live Bezier', 'Live Diagram');
  RegisterDControl(TLiveForkBlock, '', 'Live Fork', 'Live Diagram');
  RegisterDControl(TLiveJoinBlock, '', 'Live Join', 'Live Diagram');
end.

